<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HTTP Request Tool</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.7.2/font/bootstrap-icons.css" rel="stylesheet">
    <style>
        .monospace {
            font-family: 'Courier New', Courier, monospace;
        }
        .response-area {
            height: 400px;
            overflow-y: auto;
            white-space: pre-wrap;
        }
        .jwt-section {
            display: none;
        }
        .tab-content {
            padding: 20px;
            border: 1px solid #dee2e6;
            border-top: none;
            border-radius: 0 0 0.25rem 0.25rem;
        }
        .file-status {
            display: flex;
            align-items: center;
            margin-bottom: 5px;
        }
        .file-status i {
            margin-right: 8px;
        }
        .file-status.success i {
            color: #28a745;
        }
        .file-status.error i {
            color: #dc3545;
        }
        .jwt-container {
            display: flex;
            gap: 20px;
            margin-top: 20px;
        }
        .jwt-editor {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        .editor-section {
            flex: 1;
        }
        .editor-section h4 {
            margin-bottom: 5px;
        }
        .json-editor {
            width: 100%;
            height: 200px;
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-family: monospace;
            resize: vertical;
        }
        .jwt-options {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .jwt-preview {
            flex: 1;
            border: 1px solid #ccc;
            padding: 15px;
            border-radius: 4px;
        }
        #jwt-preview-content {
            white-space: pre-wrap;
            font-family: monospace;
        }
    </style>
</head>
<body>
    <nav class="navbar navbar-expand-lg navbar-dark bg-dark">
        <div class="container">
            <a class="navbar-brand" href="#">HTTP Request Tool</a>
        </div>
    </nav>

    <div class="container mt-4">
        <ul class="nav nav-tabs" id="myTab" role="tablist">
            <li class="nav-item" role="presentation">
                <button class="nav-link active" id="request-tab" data-bs-toggle="tab" data-bs-target="#request" type="button" role="tab">HTTP Request</button>
            </li>
            <li class="nav-item" role="presentation">
                <button class="nav-link" id="jwt-tab" data-bs-toggle="tab" data-bs-target="#jwt" type="button" role="tab">JWT Tools</button>
            </li>
            <li class="nav-item" role="presentation">
                <button class="nav-link" id="tools-tab" data-bs-toggle="tab" data-bs-target="#tools" type="button" role="tab">Tools</button>
            </li>
            <li class="nav-item" role="presentation">
                <button class="nav-link" id="analysis-tab" data-bs-toggle="tab" data-bs-target="#analysis" type="button" role="tab">Third Party Analysis</button>
            </li>
        </ul>

        <div class="tab-content" id="myTabContent">
            <!-- HTTP Request Tab -->
            <div class="tab-pane fade show active" id="request" role="tabpanel">
                <div class="row">
                    <div class="col-md-6">
                        <h4>Request</h4>
                        <textarea id="requestText" class="form-control monospace" rows="15"></textarea>
                        <div class="mt-3">
                            <div class="form-check">
                                <input class="form-check-input" type="checkbox" id="useProxy">
                                <label class="form-check-label" for="useProxy">Use Proxy</label>
                            </div>
                            <div class="mt-2">
                                <input type="text" id="proxyAddress" class="form-control" placeholder="Proxy Address (e.g., http://127.0.0.1:8080)" disabled>
                            </div>
                            <div class="form-check mt-2">
                                <input class="form-check-input" type="checkbox" id="verifyCert">
                                <label class="form-check-label" for="verifyCert">Verify Proxy Certificate</label>
                            </div>
                        </div>
                        <div class="mt-3">
                            <button class="btn btn-primary" onclick="sendRequest()">Send Request</button>
                            <button class="btn btn-secondary ms-2" onclick="checkCommonFiles()">Check Common Files</button>
                        </div>
                    </div>
                    <div class="col-md-6">
                        <h4>Response</h4>
                        <div id="responseText" class="form-control monospace response-area"></div>
                        <div id="commonFilesResult" class="form-control monospace response-area mt-3" style="display: none;"></div>
                    </div>
                </div>
            </div>

            <!-- JWT Tools Tab -->
            <div class="tab-pane fade" id="jwt" role="tabpanel">
                <div class="row">
                    <div class="col-md-6">
                        <h4>JWT Decoded</h4>
                        <div id="jwtText" class="form-control monospace response-area" contenteditable="true"></div>
                        <div class="mt-3">
                            <div class="form-check">
                                <input class="form-check-input" type="checkbox" id="useSecret">
                                <label class="form-check-label" for="useSecret">Use Secret Key</label>
                            </div>
                            <div class="mt-2">
                                <input type="text" id="secretEntry" class="form-control" placeholder="Secret Key" disabled>
                            </div>
                        </div>
                        <button class="btn btn-primary mt-3" onclick="saveJWT()">Save JWT</button>
                    </div>
                    <div class="col-md-6">
                        <h4>JWT Editor</h4>
                        <div id="jwt-section" class="section" style="display: none;">
                            <div class="jwt-container">
                                <div class="jwt-editor">
                                    <div class="editor-section">
                                        <h5>Header</h5>
                                        <textarea id="jwt-header" class="json-editor" placeholder="Enter JWT header JSON"></textarea>
                                    </div>
                                    <div class="editor-section">
                                        <h5>Payload</h5>
                                        <textarea id="jwt-payload" class="json-editor" placeholder="Enter JWT payload JSON"></textarea>
                                    </div>
                                    <div class="jwt-options">
                                        <label>
                                            <input type="checkbox" id="use-secret"> Use Secret Key
                                        </label>
                                        <input type="text" id="jwt-secret" placeholder="Enter secret key" style="display: none;">
                                    </div>
                                    <button onclick="saveJWT()">Save JWT</button>
                                </div>
                                <div class="jwt-preview">
                                    <h5>Preview</h5>
                                    <div id="jwt-preview-content"></div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Tools Tab -->
            <div class="tab-pane fade" id="tools" role="tabpanel">
                <div class="row">
                    <div class="col-md-12">
                        <h4>Clickjack Generator</h4>
                        <div class="input-group mb-3">
                            <input type="text" id="clickjackUrl" class="form-control" placeholder="Enter target URL">
                            <button class="btn btn-primary" onclick="generateClickjack()">Generate</button>
                        </div>
                        <div id="clickjackResult" class="form-control monospace response-area"></div>
                    </div>
                </div>
            </div>

            <!-- Third Party Analysis Tab -->
            <div class="tab-pane fade" id="analysis" role="tabpanel">
                <div class="row">
                    <div class="col-md-6">
                        <h4>TestSSL</h4>
                        <div class="input-group mb-3">
                            <input type="text" id="testsslDomain" class="form-control" placeholder="Enter domain">
                            <button class="btn btn-primary" onclick="runTestSSL()">Run TestSSL</button>
                        </div>
                        <div id="testsslResult" class="form-control monospace response-area"></div>
                    </div>
                    <div class="col-md-6">
                        <h4>Wayback Machine</h4>
                        <div class="input-group mb-3">
                            <input type="text" id="waybackUrl" class="form-control" placeholder="Enter URL">
                            <button class="btn btn-primary" onclick="searchWayback()">Search</button>
                        </div>
                        <div id="waybackResult" class="form-control monospace response-area"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script>
        // Enable/disable proxy address input based on checkbox
        document.getElementById('useProxy').addEventListener('change', function() {
            document.getElementById('proxyAddress').disabled = !this.checked;
        });

        // Enable/disable secret key input based on checkbox
        document.getElementById('useSecret').addEventListener('change', function() {
            document.getElementById('secretEntry').disabled = !this.checked;
        });

        // Auto-detect JWTs in request text
        document.getElementById('requestText').addEventListener('input', function() {
            const requestText = this.value;
            fetch('/find_jwt', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    request_text: requestText
                })
            })
            .then(response => response.json())
            .then(data => {
                if (data.tokens && data.tokens.length > 0) {
                    let decodedText = '';
                    data.tokens.forEach((token, index) => {
                        fetch('/decode_jwt', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                            },
                            body: JSON.stringify({
                                token: token
                            })
                        })
                        .then(response => response.json())
                        .then(decodedData => {
                            decodedText += `JWT #${index + 1}:\n${decodedData.decoded}\n\n`;
                            document.getElementById('jwtText').textContent = decodedText;
                        });
                    });
                } else {
                    document.getElementById('jwtText').textContent = 'No JWT tokens found in request';
                }
            });
        });

        function sendRequest() {
            const requestText = document.getElementById('requestText').value;
            const useProxy = document.getElementById('useProxy').checked;
            const proxyAddress = document.getElementById('proxyAddress').value;
            const verifyCert = document.getElementById('verifyCert').checked;

            fetch('/process_request', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    request_text: requestText,
                    use_proxy: useProxy,
                    proxy_address: proxyAddress,
                    verify_cert: verifyCert
                })
            })
            .then(response => response.json())
            .then(data => {
                if (data.error) {
                    document.getElementById('responseText').textContent = data.error;
                } else {
                    document.getElementById('responseText').textContent = data.response;
                }
            });
        }

        function generateClickjack() {
            const url = document.getElementById('clickjackUrl').value;
            fetch('/generate_clickjack', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    url: url
                })
            })
            .then(response => response.json())
            .then(data => {
                document.getElementById('clickjackResult').textContent = data.html;
            });
        }

        function checkCommonFiles() {
            const requestText = document.getElementById('requestText').value;
            const useProxy = document.getElementById('useProxy').checked;
            const proxyAddress = document.getElementById('proxyAddress').value;
            const verifyCert = document.getElementById('verifyCert').checked;

            const commonFilesResult = document.getElementById('commonFilesResult');
            commonFilesResult.style.display = 'block';
            commonFilesResult.innerHTML = '<div class="text-center"><i class="bi bi-arrow-repeat spin"></i> Checking files...</div>';

            fetch('/check_common_files', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    request_text: requestText,
                    use_proxy: useProxy,
                    proxy_address: proxyAddress,
                    verify_cert: verifyCert
                })
            })
            .then(response => response.json())
            .then(data => {
                if (data.error) {
                    commonFilesResult.innerHTML = `<div class="text-danger">${data.error}</div>`;
                } else {
                    let result = `<div>Total files checked: ${data.total_files_checked}</div>`;
                    result += `<div>Files found: ${data.files_found}</div><br>`;
                    
                    if (data.checked_files && data.checked_files.length > 0) {
                        result += '<div class="mb-3">Checking files:</div>';
                        data.checked_files.forEach(file => {
                            const statusClass = file.success ? 'success' : 'error';
                            const icon = file.success ? 'bi-check-circle-fill' : 'bi-x-circle-fill';
                            result += `<div class="file-status ${statusClass}">`;
                            result += `<i class="bi ${icon}"></i>`;
                            result += `<span>${file.file_path}</span>`;
                            if (!file.success) {
                                result += `<span class="text-muted ms-2">(Status: ${file.status_code || 'Error'})</span>`;
                            }
                            result += '</div>';
                        });
                    }
                    
                    if (data.found_files && data.found_files.length > 0) {
                        result += '<div class="mt-3">Found files:</div>';
                        data.found_files.forEach(file => {
                            result += `<div class="file-status success">`;
                            result += `<i class="bi bi-check-circle-fill"></i>`;
                            result += `<span>${file.file_path}</span>`;
                            result += `<span class="text-muted ms-2">(${file.response_length} bytes)</span>`;
                            result += '</div>';
                        });
                    }
                    
                    commonFilesResult.innerHTML = result;
                }
            });
        }

        function runTestSSL() {
            const domain = document.getElementById('testsslDomain').value;
            fetch('/run_testssl', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    domain: domain
                })
            })
            .then(response => response.json())
            .then(data => {
                if (data.error) {
                    document.getElementById('testsslResult').textContent = data.error;
                } else {
                    document.getElementById('testsslResult').textContent = data.output.join('\n');
                }
            });
        }

        function searchWayback() {
            const url = document.getElementById('waybackUrl').value;
            fetch('/search_wayback', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    url: url
                })
            })
            .then(response => response.json())
            .then(data => {
                if (data.error) {
                    document.getElementById('waybackResult').textContent = data.error;
                } else {
                    let result = `Found ${data.total_results} unique URLs:\n\n`;
                    data.results.forEach(item => {
                        const date = new Date(
                            item.timestamp.substring(0, 4),
                            item.timestamp.substring(4, 6) - 1,
                            item.timestamp.substring(6, 8),
                            item.timestamp.substring(8, 10),
                            item.timestamp.substring(10, 12),
                            item.timestamp.substring(12, 14)
                        );
                        result += `URL: ${item.original}\n`;
                        result += `First Archived: ${date.toLocaleString()}\n`;
                        result += `Status: ${item.statuscode}\n`;
                        result += `Type: ${item.mimetype}\n`;
                        result += `Size: ${(parseInt(item.length) / 1024).toFixed(2)} KB\n`;
                        result += `Archive Link: https://web.archive.org/web/${item.timestamp}/${item.original}\n`;
                        result += "-".repeat(80) + "\n\n";
                    });
                    document.getElementById('waybackResult').textContent = result;
                }
            });
        }

        function runJWTAttacks() {
            const token = document.getElementById('jwtText').textContent;
            if (!token || token === 'No JWT tokens found in request') {
                alert('No JWT token found. Please enter a request with a JWT token first.');
                return;
            }

            const attacks = [];
            if (document.getElementById('unverifiedSig').checked) {
                attacks.push('unverified_sig');
            }
            if (document.getElementById('noneSig').checked) {
                attacks.push('none_sig');
            }
            if (document.getElementById('bruteForce').checked) {
                attacks.push('brute_force');
            }
            if (document.getElementById('jwkInjection').checked) {
                attacks.push('jwk_injection');
            }
            if (document.getElementById('kidTraversal').checked) {
                attacks.push('kid_traversal');
            }
            if (document.getElementById('algorithmConfusion').checked) {
                attacks.push('algorithm_confusion');
            }

            if (attacks.length === 0) {
                alert('Please select at least one attack to run.');
                return;
            }

            // Run all selected attacks
            fetch('/run_jwt_attacks', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    token: token,
                    attacks: attacks
                })
            })
            .then(response => response.json())
            .then(data => {
                let result = 'JWT Attack Results:\n\n';
                for (const [attack, resultData] of Object.entries(data)) {
                    result += `${attack.replace(/_/g, ' ').toUpperCase()}:\n`;
                    if (resultData.error) {
                        result += `Error: ${resultData.error}\n`;
                    } else {
                        result += `Success: ${resultData.success}\n`;
                        if (resultData.modified_token) {
                            result += `Modified Token: ${resultData.modified_token}\n`;
                        }
                        if (resultData.details) {
                            result += `Details: ${resultData.details}\n`;
                        }
                    }
                    result += '\n';
                }
                alert(result);
            });
        }

        // Individual attack checkboxes
        document.getElementById('unverifiedSig').addEventListener('change', function() {
            if (this.checked) {
                runIndividualAttack('unverified_sig');
            }
        });

        document.getElementById('noneSig').addEventListener('change', function() {
            if (this.checked) {
                runIndividualAttack('none_sig');
            }
        });

        document.getElementById('bruteForce').addEventListener('change', function() {
            if (this.checked) {
                runIndividualAttack('brute_force');
            }
        });

        document.getElementById('jwkInjection').addEventListener('change', function() {
            if (this.checked) {
                runIndividualAttack('jwk_injection');
            }
        });

        document.getElementById('kidTraversal').addEventListener('change', function() {
            if (this.checked) {
                runIndividualAttack('kid_traversal');
            }
        });

        document.getElementById('algorithmConfusion').addEventListener('change', function() {
            if (this.checked) {
                runIndividualAttack('algorithm_confusion');
            }
        });

        function runIndividualAttack(attackType) {
            const token = document.getElementById('jwtText').textContent;
            if (!token || token === 'No JWT tokens found in request') {
                alert('No JWT token found. Please enter a request with a JWT token first.');
                return;
            }

            fetch(`/jwt_attack/${attackType}`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    token: token
                })
            })
            .then(response => response.json())
            .then(data => {
                let result = `${attackType.replace(/_/g, ' ').toUpperCase()} Attack Result:\n\n`;
                if (data.error) {
                    result += `Error: ${data.error}\n`;
                } else {
                    result += `Success: ${data.success}\n`;
                    if (data.modified_token) {
                        result += `Modified Token: ${data.modified_token}\n`;
                    }
                    if (data.details) {
                        result += `Details: ${data.details}\n`;
                    }
                }
                alert(result);
            });
        }

        function editJWT() {
            const jwtContent = document.getElementById('jwt-content').textContent;
            if (!jwtContent || jwtContent.includes('No JWT tokens found')) {
                alert('No JWT to edit');
                return;
            }

            try {
                const sections = jwtContent.split('\n\n');
                let header = null;
                let payload = null;

                for (const section of sections) {
                    if (section.includes('Header:')) {
                        const headerJson = section.split('Header:')[1].trim();
                        header = JSON.parse(headerJson);
                        document.getElementById('jwt-header').value = JSON.stringify(header, null, 2);
                    } else if (section.includes('Payload:')) {
                        const payloadJson = section.split('Payload:')[1].trim();
                        payload = JSON.parse(payloadJson);
                        document.getElementById('jwt-payload').value = JSON.stringify(payload, null, 2);
                    }
                }

                if (!header || !payload) {
                    throw new Error('Invalid JWT format');
                }

                document.getElementById('jwt-section').style.display = 'block';
                updateJWTPreview();
            } catch (error) {
                alert('Failed to parse JWT: ' + error.message);
            }
        }

        function updateJWTPreview() {
            try {
                const header = JSON.parse(document.getElementById('jwt-header').value);
                const payload = JSON.parse(document.getElementById('jwt-payload').value);
                const useSecret = document.getElementById('use-secret').checked;
                const secret = document.getElementById('jwt-secret').value;

                fetch('/api/edit_jwt', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        decoded_text: `Header:\n${JSON.stringify(header)}\n\nPayload:\n${JSON.stringify(payload)}`,
                        use_secret: useSecret,
                        secret: secret
                    })
                })
                .then(response => response.json())
                .then(data => {
                    if (data.error) {
                        document.getElementById('jwt-preview-content').textContent = 'Error: ' + data.error;
                    } else {
                        document.getElementById('jwt-preview-content').textContent = data.encoded_token;
                    }
                })
                .catch(error => {
                    document.getElementById('jwt-preview-content').textContent = 'Error: ' + error.message;
                });
            } catch (error) {
                document.getElementById('jwt-preview-content').textContent = 'Error: ' + error.message;
            }
        }

        function saveJWT() {
            const decodedText = document.getElementById('jwtText').textContent;
            if (!decodedText || decodedText === 'No JWT tokens found in request') {
                alert('No JWT token found to save.');
                return;
            }

            // Get the current request text
            const requestText = document.getElementById('requestText').value;
            if (!requestText) {
                alert('No request found to update.');
                return;
            }

            // Find the JWT token in the request
            fetch('/find_jwt', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    request_text: requestText
                })
            })
            .then(response => response.json())
            .then(data => {
                if (!data.tokens || data.tokens.length === 0) {
                    alert('No JWT token found in request to replace.');
                    return;
                }

                // Get the original token to replace
                const originalToken = data.tokens[0];
                
                // Edit the JWT using the new endpoint
                fetch('/edit_jwt', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        decoded_text: decodedText,
                        use_secret: document.getElementById('useSecret').checked,
                        secret: document.getElementById('secretEntry').value
                    })
                })
                .then(response => response.json())
                .then(data => {
                    if (data.error) {
                        alert(`Error editing JWT: ${data.error}`);
                        return;
                    }

                    // Replace the original token with the new one in the request
                    const newRequestText = requestText.replace(originalToken, data.encoded_token);
                    document.getElementById('requestText').value = newRequestText;
                });
            });
        }

        // Add event listeners for real-time preview
        document.getElementById('jwt-header').addEventListener('input', updateJWTPreview);
        document.getElementById('jwt-payload').addEventListener('input', updateJWTPreview);
        document.getElementById('use-secret').addEventListener('change', function() {
            document.getElementById('jwt-secret').style.display = this.checked ? 'block' : 'none';
            updateJWTPreview();
        });
        document.getElementById('jwt-secret').addEventListener('input', updateJWTPreview);
    </script>
</body>
</html> 