<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HTTP Request Tool</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.7.2/font/bootstrap-icons.css" rel="stylesheet">
    <style>
        .monospace {
            font-family: 'Courier New', Courier, monospace;
        }
        .response-area {
            height: 400px;
            overflow-y: auto;
            white-space: pre-wrap;
        }
        .container-fluid {
            padding: 0 2rem;
        }
        .jwt-section {
            display: none;
        }
        .tab-content {
            padding: 20px;
            border: 1px solid #dee2e6;
            border-top: none;
            border-radius: 0 0 0.25rem 0.25rem;
        }
        .file-status {
            display: flex;
            align-items: center;
            margin-bottom: 5px;
        }
        .file-status i {
            margin-right: 8px;
        }
        .file-status.success i {
            color: #28a745;
        }
        .file-status.error i {
            color: #dc3545;
        }
        .jwt-container {
            display: flex;
            gap: 20px;
            margin-top: 20px;
        }
        .jwt-editor {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        .editor-section {
            flex: 1;
        }
        .editor-section h4 {
            margin-bottom: 5px;
        }
        .json-editor {
            width: 100%;
            height: 200px;
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-family: monospace;
            resize: vertical;
        }
        .jwt-options {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .jwt-preview {
            flex: 1;
            border: 1px solid #ccc;
            padding: 15px;
            border-radius: 4px;
        }
        #jwt-preview-content {
            white-space: pre-wrap;
            font-family: monospace;
        }
        .security-finding {
            padding: 10px;
            margin-bottom: 10px;
            border-radius: 4px;
        }
        .security-finding.warning {
            background-color: #fff3cd;
            border: 1px solid #ffeeba;
        }
        .security-finding.danger {
            background-color: #f8d7da;
            border: 1px solid #f5c6cb;
        }
        .security-finding.info {
            background-color: #d1ecf1;
            border: 1px solid #bee5eb;
        }
    </style>
</head>
<body>
    <nav class="navbar navbar-expand-lg navbar-dark bg-dark">
        <div class="container">
            <a class="navbar-brand" href="#">HTTP Request Tool</a>
        </div>
    </nav>

    <div class="container-fluid mt-4">
        <ul class="nav nav-tabs" id="myTab" role="tablist">
            <li class="nav-item" role="presentation">
                <button class="nav-link active" id="request-tab" data-bs-toggle="tab" data-bs-target="#request" type="button" role="tab">HTTP Request</button>
            </li>
            <li class="nav-item" role="presentation">
                <button class="nav-link" id="jwt-tab" data-bs-toggle="tab" data-bs-target="#jwt" type="button" role="tab">JWT Tools</button>
            </li>
            <li class="nav-item" role="presentation">
                <button class="nav-link" id="tools-tab" data-bs-toggle="tab" data-bs-target="#tools" type="button" role="tab">Tools</button>
            </li>
            <li class="nav-item" role="presentation">
                <button class="nav-link" id="analysis-tab" data-bs-toggle="tab" data-bs-target="#analysis" type="button" role="tab">Third Party Analysis</button>
            </li>
        </ul>

        <div class="tab-content" id="myTabContent">
            <!-- HTTP Request Tab -->
            <div class="tab-pane fade show active" id="request" role="tabpanel">
                <div class="row">
                    <div class="col-md-4">
                        <h4>Request</h4>
                        <textarea id="requestText" class="form-control monospace response-area"></textarea>
                    </div>
                    <div class="col-md-4">
                        <h4>Response</h4>
                        <div id="responseText" class="form-control monospace response-area"></div>
                        <div id="commonFilesResult" class="form-control monospace response-area mt-3" style="display: none;"></div>
                    </div>
                    <div class="col-md-4">
                        <h4>Header Analysis</h4>
                        <div id="headerAnalysisResult" class="form-control monospace response-area">
                            <div class="text-muted">Click "Header Analysis" to see results...</div>
                        </div>
                    </div>
                </div>
                <div class="row mt-3">
                    <div class="col-md-12">
                        <div class="d-flex align-items-center gap-3">
                            <div class="form-check">
                                <input class="form-check-input" type="checkbox" id="useProxy">
                                <label class="form-check-label" for="useProxy">Use Proxy</label>
                            </div>
                            <div class="flex-grow-1">
                                <input type="text" id="proxyAddress" class="form-control" placeholder="Proxy Address (e.g., http://127.0.0.1:8080)" disabled>
                            </div>
                            <div class="form-check">
                                <input class="form-check-input" type="checkbox" id="verifyCert">
                                <label class="form-check-label" for="verifyCert">Verify Proxy Certificate</label>
                            </div>
                            <button class="btn btn-secondary" onclick="checkCommonFiles()">Check Common Files</button>
                            <button class="btn btn-info" onclick="analyzeHeaders()">Header Analysis</button>
                            <button class="btn btn-primary" onclick="sendRequest()">Send Request</button>
                        </div>
                    </div>
                </div>
                <div class="row mt-3">
                    <div class="col-md-12">
                        <h4>Security Findings</h4>
                        <div id="securityFindings" class="form-control monospace response-area">
                            <div class="text-muted">Click "Header Analysis" to see security findings...</div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- JWT Tools Tab -->
            <div class="tab-pane fade" id="jwt" role="tabpanel">
                <div class="row">
                    <div class="col-md-6">
                        <h4>JWT Decoded</h4>
                        <div id="jwtText" class="form-control monospace response-area" contenteditable="true"></div>
                        <div class="mt-3">
                            <div class="form-check">
                                <input class="form-check-input" type="checkbox" id="useSecret">
                                <label class="form-check-label" for="useSecret">Use Secret Key</label>
                            </div>
                            <div class="mt-2">
                                <input type="text" id="secretEntry" class="form-control" placeholder="Secret Key" disabled>
                            </div>
                        </div>
                        <button class="btn btn-primary mt-3" onclick="saveJWT()">Save JWT</button>
                    </div>
                    <div class="col-md-6">
                        <h4>JWT Attacks</h4>
                        <div class="form-check">
                            <input class="form-check-input" type="radio" name="jwtAttack" id="unverifiedSig">
                            <label class="form-check-label" for="unverifiedSig">Unverified Signature Attack</label>
                        </div>
                        <div class="form-check">
                            <input class="form-check-input" type="radio" name="jwtAttack" id="noneSig">
                            <label class="form-check-label" for="noneSig">None Signature Attack</label>
                        </div>
                        <div class="form-check">
                            <input class="form-check-input" type="radio" name="jwtAttack" id="bruteForce">
                            <label class="form-check-label" for="bruteForce">Brute Force Secret Key</label>
                        </div>
                        <div class="form-check">
                            <input class="form-check-input" type="radio" name="jwtAttack" id="jwkInjection">
                            <label class="form-check-label" for="jwkInjection">JWK Header Injection</label>
                        </div>
                        <div class="form-check">
                            <input class="form-check-input" type="radio" name="jwtAttack" id="kidTraversal">
                            <label class="form-check-label" for="kidTraversal">KID Header Path Traversal</label>
                        </div>
                        <div class="form-check">
                            <input class="form-check-input" type="radio" name="jwtAttack" id="algorithmConfusion">
                            <label class="form-check-label" for="algorithmConfusion">Algorithm Confusion</label>
                        </div>
                        <button class="btn btn-primary mt-3" onclick="runJWTAttacks()">Run Selected JWT Attack</button>
                    </div>
                </div>
            </div>

            <!-- Tools Tab -->
            <div class="tab-pane fade" id="tools" role="tabpanel">
                <div class="row">
                    <div class="col-md-12">
                        <h4>Clickjack Generator</h4>
                        <div class="input-group mb-3">
                            <input type="text" id="clickjackUrl" class="form-control" placeholder="Enter target URL">
                            <button class="btn btn-primary" onclick="generateClickjack()">Generate</button>
                        </div>
                        <div id="clickjackResult" class="form-control monospace response-area"></div>
                    </div>
                </div>
            </div>

            <!-- Third Party Analysis Tab -->
            <div class="tab-pane fade" id="analysis" role="tabpanel">
                <div class="row">
                    <div class="col-md-6">
                        <h4>TestSSL</h4>
                        <div class="input-group mb-3">
                            <input type="text" id="testsslDomain" class="form-control" placeholder="Enter domain">
                            <button class="btn btn-primary" onclick="runTestSSL()">Run TestSSL</button>
                        </div>
                        <div id="testsslResult" class="form-control monospace response-area"></div>
                    </div>
                    <div class="col-md-6">
                        <h4>Wayback Machine</h4>
                        <div class="input-group mb-3">
                            <input type="text" id="waybackUrl" class="form-control" placeholder="Enter URL">
                            <button class="btn btn-primary" onclick="searchWayback()">Search</button>
                        </div>
                        <div id="waybackResult" class="form-control monospace response-area"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script>
        // Enable/disable proxy address input based on checkbox
        document.getElementById('useProxy').addEventListener('change', function() {
            document.getElementById('proxyAddress').disabled = !this.checked;
        });

        // Enable/disable secret key input based on checkbox
        document.getElementById('useSecret').addEventListener('change', function() {
            document.getElementById('secretEntry').disabled = !this.checked;
        });

        // Auto-detect JWTs in request text
        document.getElementById('requestText').addEventListener('input', function() {
            const requestText = this.value;
            if (!requestText.trim()) {
                document.getElementById('jwtText').textContent = 'No JWT tokens found in request';
                return;
            }
            
            fetch('/find_jwt', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    request_text: requestText
                })
            })
            .then(response => response.json())
            .then(data => {
                if (data.tokens && data.tokens.length > 0) {
                    let decodedText = '';
                    data.tokens.forEach((token, index) => {
                        fetch('/decode_jwt', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                            },
                            body: JSON.stringify({
                                token: token
                            })
                        })
                        .then(response => response.json())
                        .then(decodedData => {
                            if (decodedData.decoded) {
                                decodedText += `JWT #${index + 1}:\n${decodedData.decoded}\n\n`;
                                document.getElementById('jwtText').textContent = decodedText;
                            } else {
                                document.getElementById('jwtText').textContent = 'Error decoding JWT';
                            }
                        })
                        .catch(error => {
                            document.getElementById('jwtText').textContent = 'Error decoding JWT';
                        });
                    });
                } else {
                    document.getElementById('jwtText').textContent = 'No JWT tokens found in request';
                }
            })
            .catch(error => {
                document.getElementById('jwtText').textContent = 'Error finding JWT tokens';
            });
        });

        function sendRequest() {
            const requestText = document.getElementById('requestText').value;
            const useProxy = document.getElementById('useProxy').checked;
            const proxyAddress = document.getElementById('proxyAddress').value;
            const verifyCert = document.getElementById('verifyCert').checked;

            fetch('/process_request', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    request_text: requestText,
                    use_proxy: useProxy,
                    proxy_address: proxyAddress,
                    verify_cert: verifyCert
                })
            })
            .then(response => response.json())
            .then(data => {
                if (data.error) {
                    document.getElementById('responseText').textContent = data.error;
                } else {
                    document.getElementById('responseText').textContent = data.response;
                }
            });
        }

        function generateClickjack() {
            const url = document.getElementById('clickjackUrl').value;
            fetch('/generate_clickjack', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    url: url
                })
            })
            .then(response => response.json())
            .then(data => {
                document.getElementById('clickjackResult').textContent = data.html;
            });
        }

        function checkCommonFiles() {
            const requestText = document.getElementById('requestText').value;
            const useProxy = document.getElementById('useProxy').checked;
            const proxyAddress = document.getElementById('proxyAddress').value;
            const verifyCert = document.getElementById('verifyCert').checked;

            const commonFilesResult = document.getElementById('commonFilesResult');
            commonFilesResult.style.display = 'block';
            commonFilesResult.innerHTML = '<div class="text-center"><i class="bi bi-arrow-repeat spin"></i> Checking files...</div>';

            fetch('/check_common_files', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    request_text: requestText,
                    use_proxy: useProxy,
                    proxy_address: proxyAddress,
                    verify_cert: verifyCert
                })
            })
            .then(response => response.json())
            .then(data => {
                if (data.error) {
                    commonFilesResult.innerHTML = `<div class="text-danger">${data.error}</div>`;
                } else {
                    let result = `<div>Total files checked: ${data.total_files_checked}</div>`;
                    result += `<div>Files found: ${data.files_found}</div><br>`;
                    
                    if (data.checked_files && data.checked_files.length > 0) {
                        result += '<div class="mb-3">Checking files:</div>';
                        data.checked_files.forEach(file => {
                            const statusClass = file.success ? 'success' : 'error';
                            const icon = file.success ? 'bi-check-circle-fill' : 'bi-x-circle-fill';
                            result += `<div class="file-status ${statusClass}">`;
                            result += `<i class="bi ${icon}"></i>`;
                            result += `<span>${file.file_path}</span>`;
                            if (!file.success) {
                                result += `<span class="text-muted ms-2">(Status: ${file.status_code || 'Error'})</span>`;
                            }
                            result += '</div>';
                        });
                    }
                    
                    if (data.found_files && data.found_files.length > 0) {
                        result += '<div class="mt-3">Found files:</div>';
                        data.found_files.forEach(file => {
                            result += `<div class="file-status success">`;
                            result += `<i class="bi bi-check-circle-fill"></i>`;
                            result += `<span>${file.file_path}</span>`;
                            result += `<span class="text-muted ms-2">(${file.response_length} bytes)</span>`;
                            result += '</div>';
                        });
                    }
                    
                    commonFilesResult.innerHTML = result;
                }
            });
        }

        function runTestSSL() {
            const domain = document.getElementById('testsslDomain').value;
            const resultArea = document.getElementById('testsslResult');
            resultArea.textContent = 'Running TestSSL...\n';
            
            fetch('/run_testssl', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    domain: domain
                })
            })
            .then(response => {
                const reader = response.body.getReader();
                const decoder = new TextDecoder();
                
                function readStream() {
                    reader.read().then(({done, value}) => {
                        if (done) {
                            return;
                        }
                        
                        const chunk = decoder.decode(value);
                        const lines = chunk.split('\n');
                        
                        for (const line of lines) {
                            if (line.trim()) {
                                try {
                                    const data = JSON.parse(line);
                                    if (data.error) {
                                        resultArea.textContent += `Error: ${data.error}\n`;
                                    } else if (data.output) {
                                        resultArea.textContent += data.output;
                                        resultArea.scrollTop = resultArea.scrollHeight;
                                    }
                                } catch (e) {
                                    // Skip invalid JSON
                                }
                            }
                        }
                        
                        readStream();
                    });
                }
                
                readStream();
            })
            .catch(error => {
                resultArea.textContent += `Error: ${error.message}\n`;
            });
        }

        function searchWayback() {
            const url = document.getElementById('waybackUrl').value;
            const resultArea = document.getElementById('waybackResult');
            resultArea.textContent = 'Starting Wayback Machine search...\n';
            
            fetch('/search_wayback', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    url: url
                })
            })
            .then(response => {
                const reader = response.body.getReader();
                const decoder = new TextDecoder();
                
                function readStream() {
                    reader.read().then(({done, value}) => {
                        if (done) {
                            return;
                        }
                        
                        const chunk = decoder.decode(value);
                        const lines = chunk.split('\n');
                        
                        for (const line of lines) {
                            if (line.trim()) {
                                try {
                                    const data = JSON.parse(line);
                                    if (data.error) {
                                        resultArea.textContent += `Error: ${data.error}\n`;
                                    } else if (data.output) {
                                        resultArea.textContent += data.output;
                                        resultArea.scrollTop = resultArea.scrollHeight;
                                    }
                                } catch (e) {
                                    // Skip invalid JSON
                                }
                            }
                        }
                        
                        readStream();
                    });
                }
                
                readStream();
            })
            .catch(error => {
                resultArea.textContent += `Error: ${error.message}\n`;
            });
        }

        function runJWTAttacks() {
            // Get the request text from the HTTP Request tab
            const requestText = document.getElementById('requestText').value;
            if (!requestText) {
                alert('No request found. Please enter a request with a JWT token first.');
                return;
            }

            // Get proxy settings
            const useProxy = document.getElementById('useProxy').checked;
            const proxyAddress = document.getElementById('proxyAddress').value;
            const verifyCert = document.getElementById('verifyCert').checked;

            // Find JWT tokens in the request
            fetch('/find_jwt', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    request_text: requestText
                })
            })
            .then(response => response.json())
            .then(data => {
                if (!data.tokens || data.tokens.length === 0) {
                    alert('No JWT token found in request. Please enter a request with a JWT token first.');
                    return;
                }

                // Get the selected attack
                let selectedAttack = null;
                const attackTypes = {
                    'unverifiedSig': 'unverified_sig',
                    'noneSig': 'none_sig',
                    'bruteForce': 'brute_force',
                    'jwkInjection': 'jwk_injection',
                    'kidTraversal': 'kid_traversal',
                    'algorithmConfusion': 'algorithm_confusion'
                };

                for (const [id, attack] of Object.entries(attackTypes)) {
                    if (document.getElementById(id).checked) {
                        selectedAttack = attack;
                        break;
                    }
                }

                if (!selectedAttack) {
                    alert('Please select an attack to run.');
                    return;
                }

                // For brute force attack, show progress in a modal
                if (selectedAttack === 'brute_force') {
                    const modal = document.createElement('div');
                    modal.className = 'modal fade';
                    modal.id = 'bruteForceModal';
                    modal.setAttribute('tabindex', '-1');
                    modal.innerHTML = `
                        <div class="modal-dialog modal-lg">
                            <div class="modal-content">
                                <div class="modal-header">
                                    <h5 class="modal-title">Brute Force Attack Progress</h5>
                                    <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
                                </div>
                                <div class="modal-body">
                                    <div class="progress mb-3">
                                        <div class="progress-bar progress-bar-striped progress-bar-animated" role="progressbar" style="width: 0%"></div>
                                    </div>
                                    <pre id="bruteForceOutput" class="bg-dark text-light p-3" style="max-height: 300px; overflow-y: auto;"></pre>
                                </div>
                            </div>
                        </div>
                    `;
                    document.body.appendChild(modal);
                    const bruteForceModal = new bootstrap.Modal(modal);
                    bruteForceModal.show();

                    // Update output every second
                    const outputInterval = setInterval(() => {
                        fetch(`/jwt_attack/${selectedAttack}`, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                            },
                            body: JSON.stringify({
                                token: data.tokens[0],
                                request_text: requestText,
                                use_proxy: useProxy,
                                proxy_address: proxyAddress,
                                verify_cert: verifyCert
                            })
                        })
                        .then(response => response.json())
                        .then(data => {
                            const output = document.getElementById('bruteForceOutput');
                            if (data.error) {
                                output.textContent = `Error: ${data.error}\nDetails: ${data.details || 'No additional details available'}`;
                                if (data.output && data.output.length > 0) {
                                    output.textContent += '\n\nHashcat Output:\n' + data.output.join('\n');
                                }
                                clearInterval(outputInterval);
                            } else if (data.success) {
                                // Parse the hashcat output to find the JWT:secret line
                                const hashcatOutput = data.output.join('\n');
                                // Look for the line that contains the JWT followed by a colon and the secret
                                const secretMatch = hashcatOutput.match(/^([^:]+):([^\s]+)$/m);
                                if (secretMatch) {
                                    const jwt = secretMatch[1];
                                    const secret = secretMatch[2];
                                    output.textContent = `Success! Found secret: ${secret}\n\nHashcat Output:\n${hashcatOutput}`;
                                } else {
                                    output.textContent = `Success! Found secret: ${data.secret}\n\nHashcat Output:\n${hashcatOutput}`;
                                }
                                clearInterval(outputInterval);
                            } else if (data.output) {
                                output.textContent = data.output.join('\n');
                            }
                        })
                        .catch(error => {
                            const output = document.getElementById('bruteForceOutput');
                            output.textContent = `Error: ${error.message}`;
                            clearInterval(outputInterval);
                        });
                    }, 1000);

                    // Clean up interval when modal is closed
                    modal.addEventListener('hidden.bs.modal', function () {
                        clearInterval(outputInterval);
                    });
                } else {
                    // For other attacks, show alert with results and update the request
                    let message = `${selectedAttack.replace(/_/g, ' ').toUpperCase()}:\n`;
                    if (data.error) {
                        message += `Error: ${data.error}`;
                        alert(message);
                    } else {
                        message += `Success: ${data.success}\n`;
                        if (data.all_results && selectedAttack === 'none_sig') {
                            message += '\nAttempted variations:\n';
                            data.all_results.forEach(result => {
                                message += `\n${result.variation}:\n`;
                                message += `Status Code: ${result.status_code}\n`;
                                message += `Success: ${result.success ? 'Yes' : 'No'}\n`;
                            });
                        }
                        if (data.modified_token) {
                            message += `\nModified Token: ${data.modified_token}\n`;
                            // Update the request with the modified token
                            const newRequestText = requestText.replace(data.tokens[0], data.modified_token);
                            document.getElementById('requestText').value = newRequestText;
                            // Also update the decoded JWT display
                            fetch('/decode_jwt', {
                                method: 'POST',
                                headers: {
                                    'Content-Type': 'application/json',
                                },
                                body: JSON.stringify({
                                    token: data.modified_token
                                })
                            })
                            .then(response => response.json())
                            .then(decodedData => {
                                if (decodedData.decoded) {
                                    document.getElementById('jwtText').textContent = decodedData.decoded;
                                }
                            });
                        }
                        if (data.details) {
                            message += `\nDetails: ${data.details}`;
                        }
                        alert(message);
                    }
                }
            });
        }

        function saveJWT() {
            const decodedText = document.getElementById('jwtText').textContent;
            if (!decodedText || decodedText === 'No JWT tokens found in request') {
                alert('No JWT token found to save.');
                return;
            }

            // Get the current request text
            const requestText = document.getElementById('requestText').value;
            if (!requestText) {
                alert('No request found to update.');
                return;
            }

            // Find the JWT token in the request
            fetch('/find_jwt', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    request_text: requestText
                })
            })
            .then(response => response.json())
            .then(data => {
                if (!data.tokens || data.tokens.length === 0) {
                    alert('No JWT token found in request to replace.');
                    return;
                }

                // Get the original token to replace
                const originalToken = data.tokens[0];
                
                // Edit the JWT using the new endpoint
                fetch('/edit_jwt', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        decoded_text: decodedText,
                        use_secret: document.getElementById('useSecret').checked,
                        secret: document.getElementById('secretEntry').value
                    })
                })
                .then(response => response.json())
                .then(data => {
                    if (data.error) {
                        alert(`Error editing JWT: ${data.error}`);
                        return;
                    }

                    // Replace the original token with the new one in the request
                    const newRequestText = requestText.replace(originalToken, data.encoded_token);
                    document.getElementById('requestText').value = newRequestText;
                    alert('JWT successfully saved and updated in request!');
                });
            });
        }

        function analyzeHeaders() {
            const requestText = document.getElementById('requestText').value;
            const responseText = document.getElementById('responseText').textContent;
            
            if (!requestText && !responseText) {
                alert('Please enter a request or response first.');
                return;
            }

            const headerAnalysisResult = document.getElementById('headerAnalysisResult');
            const securityFindings = document.getElementById('securityFindings');
            headerAnalysisResult.style.display = 'block';
            headerAnalysisResult.innerHTML = '<div class="text-center"><i class="bi bi-arrow-repeat spin"></i> Analyzing headers...</div>';
            securityFindings.innerHTML = '<div class="text-center"><i class="bi bi-arrow-repeat spin"></i> Analyzing security findings...</div>';

            // Combine request and response text if both exist
            const combinedText = requestText + (responseText ? '\n\n' + responseText : '');

            fetch('/analyze_headers', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    request_text: combinedText
                })
            })
            .then(response => response.json())
            .then(data => {
                if (data.error) {
                    headerAnalysisResult.innerHTML = `<div class="text-danger">${data.error}</div>`;
                    securityFindings.innerHTML = `<div class="text-danger">${data.error}</div>`;
                    return;
                }

                let result = `<div class="mb-3">Header Analysis Results:</div>`;
                result += `<div>Total Headers: ${data.total_headers}</div>`;
                result += `<div>Request Headers: ${data.request_headers}</div>`;
                result += `<div>Response Headers: ${data.response_headers}</div>`;
                result += `<div>Standard Headers: ${data.standard_headers}</div>`;
                result += `<div>Custom Headers: ${data.custom_headers}</div>`;

                // Group headers by type and filter out empty/invalid headers
                const requestHeaders = data.headers.filter(h => 
                    h.type === 'request' && 
                    h.header && 
                    h.header.trim() !== '' && 
                    h.value !== undefined && 
                    h.value !== null
                );
                const responseHeaders = data.headers.filter(h => 
                    h.type === 'response' && 
                    h.header && 
                    h.header.trim() !== '' && 
                    h.value !== undefined && 
                    h.value !== null
                );

                // Display Request Headers
                if (requestHeaders.length > 0) {
                    result += `<div class="mt-3"><h5>Request Headers:</h5></div>`;
                    requestHeaders.forEach(header => {
                        const headerClass = header.is_standard ? 'success' : 'warning';
                        result += `<div class="header-item ${headerClass} p-2 mb-2 rounded">`;
                        result += `<div>Header Name: ${header.header}</div>`;
                        result += `<div>Value: ${header.value}</div>`;
                        result += `<div>Description: ${header.is_standard ? header.description : 'Custom Header'}</div>`;
                        result += `</div>`;
                    });
                }

                // Display Response Headers
                if (responseHeaders.length > 0) {
                    result += `<div class="mt-3"><h5>Response Headers:</h5></div>`;
                    responseHeaders.forEach(header => {
                        const headerClass = header.is_standard ? 'success' : 'warning';
                        result += `<div class="header-item ${headerClass} p-2 mb-2 rounded">`;
                        result += `<div>Header Name: ${header.header}</div>`;
                        result += `<div>Value: ${header.value}</div>`;
                        result += `<div>Description: ${header.is_standard ? header.description : 'Custom Header'}</div>`;
                        result += `</div>`;
                    });
                }

                headerAnalysisResult.innerHTML = result;

                // Analyze security findings
                let securityFindingsHtml = '<div class="mb-3">Security Findings:</div>';
                
                // Check for missing security headers
                const requiredHeaders = [
                    'Strict-Transport-Security',
                    'Content-Security-Policy',
                    'X-Content-Type-Options',
                    'X-Frame-Options'
                ];
                
                const missingHeaders = requiredHeaders.filter(header => 
                    !responseHeaders.some(h => h.header.toLowerCase() === header.toLowerCase())
                );
                
                if (missingHeaders.length > 0) {
                    securityFindingsHtml += `<div class="security-finding danger">
                        <h5><i class="bi bi-exclamation-triangle-fill"></i> Missing Security Headers</h5>
                        <p>The following security headers are missing:</p>
                        <ul>${missingHeaders.map(h => `<li>${h}</li>`).join('')}</ul>
                    </div>`;
                }

                // Check for deprecated X-XSS-Protection header
                const xssProtectionHeader = responseHeaders.find(h => h.header.toLowerCase() === 'x-xss-protection');
                if (xssProtectionHeader) {
                    securityFindingsHtml += `<div class="security-finding warning">
                        <h5><i class="bi bi-exclamation-circle-fill"></i> Deprecated X-XSS-Protection Header</h5>
                        <p>The X-XSS-Protection header is deprecated and should be removed. Modern browsers use Content-Security-Policy instead.</p>
                        <p>Current value: ${xssProtectionHeader.value}</p>
                    </div>`;
                }

                // Check for custom headers
                const customHeaders = responseHeaders.filter(h => !h.is_standard);
                if (customHeaders.length > 0) {
                    securityFindingsHtml += `<div class="security-finding warning">
                        <h5><i class="bi bi-exclamation-circle-fill"></i> Custom Headers Found</h5>
                        <p>The following custom headers should be reviewed:</p>
                        <ul>${customHeaders.map(h => `<li>${h.header}: ${h.value}</li>`).join('')}</ul>
                    </div>`;
                }

                // Check for Server header
                const serverHeader = responseHeaders.find(h => h.header.toLowerCase() === 'server');
                if (serverHeader) {
                    securityFindingsHtml += `<div class="security-finding danger">
                        <h5><i class="bi bi-exclamation-triangle-fill"></i> Server Information Disclosure</h5>
                        <p>The Server header reveals server information: ${serverHeader.value}</p>
                    </div>`;
                }

                // Check for Via header
                const viaHeader = responseHeaders.find(h => h.header.toLowerCase() === 'via');
                if (viaHeader) {
                    securityFindingsHtml += `<div class="security-finding warning">
                        <h5><i class="bi bi-exclamation-circle-fill"></i> Internal IP Disclosure</h5>
                        <p>The Via header may reveal internal IP addresses: ${viaHeader.value}</p>
                    </div>`;
                }

                // Check for Set-Cookie security flags
                const setCookieHeaders = responseHeaders.filter(h => h.header.toLowerCase() === 'set-cookie');
                setCookieHeaders.forEach(header => {
                    const value = header.value.toLowerCase();
                    const issues = [];
                    
                    if (value.includes('domain=*')) {
                        issues.push('Wildcard domain (*) is not recommended');
                    }
                    if (!value.includes('httponly')) {
                        issues.push('Missing HttpOnly flag');
                    }
                    if (!value.includes('secure')) {
                        issues.push('Missing Secure flag');
                    }
                    
                    if (issues.length > 0) {
                        securityFindingsHtml += `<div class="security-finding danger">
                            <h5><i class="bi bi-exclamation-triangle-fill"></i> Cookie Security Issues</h5>
                            <p>Cookie security issues found:</p>
                            <ul>${issues.map(issue => `<li>${issue}</li>`).join('')}</ul>
                        </div>`;
                    }
                });

                // Check for Content-Security-Policy
                const cspHeader = responseHeaders.find(h => 
                    h.header.toLowerCase() === 'content-security-policy' || 
                    h.header.toLowerCase() === 'x-content-security-policy'
                );
                if (cspHeader) {
                    const value = cspHeader.value.toLowerCase();
                    const issues = [];
                    
                    if (value.includes('unsafe-inline')) {
                        issues.push('unsafe-inline is not recommended');
                    }
                    if (value.includes('unsafe-eval')) {
                        issues.push('unsafe-eval is not recommended');
                    }
                    
                    // Log script-src for review
                    const scriptSrcMatch = value.match(/script-src\s+([^;]+)/i);
                    if (scriptSrcMatch) {
                        securityFindingsHtml += `<div class="security-finding info">
                            <h5><i class="bi bi-info-circle-fill"></i> Content-Security-Policy Script Sources</h5>
                            <p>Script sources should be reviewed: ${scriptSrcMatch[1]}</p>
                        </div>`;
                    }
                    
                    if (issues.length > 0) {
                        securityFindingsHtml += `<div class="security-finding danger">
                            <h5><i class="bi bi-exclamation-triangle-fill"></i> Content-Security-Policy Issues</h5>
                            <p>The following CSP issues were found:</p>
                            <ul>${issues.map(issue => `<li>${issue}</li>`).join('')}</ul>
                        </div>`;
                    }
                }

                securityFindings.innerHTML = securityFindingsHtml;
            })
            .catch(error => {
                headerAnalysisResult.innerHTML = `<div class="text-danger">Error: ${error.message}</div>`;
                securityFindings.innerHTML = `<div class="text-danger">Error: ${error.message}</div>`;
            });
        }
    </script>
</body>
</html> 