<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HTTP Request Tool</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.7.2/font/bootstrap-icons.css" rel="stylesheet">
    <style>
        .monospace {
            font-family: 'Courier New', Courier, monospace;
        }
        .response-area {
            height: 400px;
            overflow-y: auto;
            white-space: pre-wrap;
        }
        .jwt-section {
            display: none;
        }
        .tab-content {
            padding: 20px;
            border: 1px solid #dee2e6;
            border-top: none;
            border-radius: 0 0 0.25rem 0.25rem;
        }
        .file-status {
            display: flex;
            align-items: center;
            margin-bottom: 5px;
        }
        .file-status i {
            margin-right: 8px;
        }
        .file-status.success i {
            color: #28a745;
        }
        .file-status.error i {
            color: #dc3545;
        }
        .jwt-container {
            display: flex;
            gap: 20px;
            margin-top: 20px;
        }
        .jwt-editor {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        .editor-section {
            flex: 1;
        }
        .editor-section h4 {
            margin-bottom: 5px;
        }
        .json-editor {
            width: 100%;
            height: 200px;
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-family: monospace;
            resize: vertical;
        }
        .jwt-options {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .jwt-preview {
            flex: 1;
            border: 1px solid #ccc;
            padding: 15px;
            border-radius: 4px;
        }
        #jwt-preview-content {
            white-space: pre-wrap;
            font-family: monospace;
        }
    </style>
</head>
<body>
    <nav class="navbar navbar-expand-lg navbar-dark bg-dark">
        <div class="container">
            <a class="navbar-brand" href="#">HTTP Request Tool</a>
        </div>
    </nav>

    <div class="container mt-4">
        <ul class="nav nav-tabs" id="myTab" role="tablist">
            <li class="nav-item" role="presentation">
                <button class="nav-link active" id="request-tab" data-bs-toggle="tab" data-bs-target="#request" type="button" role="tab">HTTP Request</button>
            </li>
            <li class="nav-item" role="presentation">
                <button class="nav-link" id="jwt-tab" data-bs-toggle="tab" data-bs-target="#jwt" type="button" role="tab">JWT Tools</button>
            </li>
            <li class="nav-item" role="presentation">
                <button class="nav-link" id="tools-tab" data-bs-toggle="tab" data-bs-target="#tools" type="button" role="tab">Tools</button>
            </li>
            <li class="nav-item" role="presentation">
                <button class="nav-link" id="analysis-tab" data-bs-toggle="tab" data-bs-target="#analysis" type="button" role="tab">Third Party Analysis</button>
            </li>
        </ul>

        <div class="tab-content" id="myTabContent">
            <!-- HTTP Request Tab -->
            <div class="tab-pane fade show active" id="request" role="tabpanel">
                <div class="row">
                    <div class="col-md-6">
                        <h4>Request</h4>
                        <textarea id="requestText" class="form-control monospace" rows="15"></textarea>
                        <div class="mt-3">
                            <div class="form-check">
                                <input class="form-check-input" type="checkbox" id="useProxy">
                                <label class="form-check-label" for="useProxy">Use Proxy</label>
                            </div>
                            <div class="mt-2">
                                <input type="text" id="proxyAddress" class="form-control" placeholder="Proxy Address (e.g., http://127.0.0.1:8080)" disabled>
                            </div>
                            <div class="form-check mt-2">
                                <input class="form-check-input" type="checkbox" id="verifyCert">
                                <label class="form-check-label" for="verifyCert">Verify Proxy Certificate</label>
                            </div>
                        </div>
                        <div class="mt-3">
                            <button class="btn btn-primary" onclick="sendRequest()">Send Request</button>
                            <button class="btn btn-secondary ms-2" onclick="checkCommonFiles()">Check Common Files</button>
                        </div>
                    </div>
                    <div class="col-md-6">
                        <h4>Response</h4>
                        <div id="responseText" class="form-control monospace response-area"></div>
                        <div id="commonFilesResult" class="form-control monospace response-area mt-3" style="display: none;"></div>
                    </div>
                </div>
            </div>

            <!-- JWT Tools Tab -->
            <div class="tab-pane fade" id="jwt" role="tabpanel">
                <div class="row">
                    <div class="col-md-6">
                        <h4>JWT Decoded</h4>
                        <div id="jwtText" class="form-control monospace response-area" contenteditable="true"></div>
                        <div class="mt-3">
                            <div class="form-check">
                                <input class="form-check-input" type="checkbox" id="useSecret">
                                <label class="form-check-label" for="useSecret">Use Secret Key</label>
                            </div>
                            <div class="mt-2">
                                <input type="text" id="secretEntry" class="form-control" placeholder="Secret Key" disabled>
                            </div>
                        </div>
                        <button class="btn btn-primary mt-3" onclick="saveJWT()">Save JWT</button>
                    </div>
                    <div class="col-md-6">
                        <h4>JWT Attacks</h4>
                        <div class="form-check">
                            <input class="form-check-input" type="radio" name="jwtAttack" id="unverifiedSig">
                            <label class="form-check-label" for="unverifiedSig">Unverified Signature Attack</label>
                        </div>
                        <div class="form-check">
                            <input class="form-check-input" type="radio" name="jwtAttack" id="noneSig">
                            <label class="form-check-label" for="noneSig">None Signature Attack</label>
                        </div>
                        <div class="form-check">
                            <input class="form-check-input" type="radio" name="jwtAttack" id="bruteForce">
                            <label class="form-check-label" for="bruteForce">Brute Force Secret Key</label>
                        </div>
                        <div class="form-check">
                            <input class="form-check-input" type="radio" name="jwtAttack" id="jwkInjection">
                            <label class="form-check-label" for="jwkInjection">JWK Header Injection</label>
                        </div>
                        <div class="form-check">
                            <input class="form-check-input" type="radio" name="jwtAttack" id="kidTraversal">
                            <label class="form-check-label" for="kidTraversal">KID Header Path Traversal</label>
                        </div>
                        <div class="form-check">
                            <input class="form-check-input" type="radio" name="jwtAttack" id="algorithmConfusion">
                            <label class="form-check-label" for="algorithmConfusion">Algorithm Confusion</label>
                        </div>
                        <button class="btn btn-primary mt-3" onclick="runJWTAttacks()">Run Selected JWT Attack</button>
                    </div>
                </div>
            </div>

            <!-- Tools Tab -->
            <div class="tab-pane fade" id="tools" role="tabpanel">
                <div class="row">
                    <div class="col-md-12">
                        <h4>Clickjack Generator</h4>
                        <div class="input-group mb-3">
                            <input type="text" id="clickjackUrl" class="form-control" placeholder="Enter target URL">
                            <button class="btn btn-primary" onclick="generateClickjack()">Generate</button>
                        </div>
                        <div id="clickjackResult" class="form-control monospace response-area"></div>
                    </div>
                </div>
            </div>

            <!-- Third Party Analysis Tab -->
            <div class="tab-pane fade" id="analysis" role="tabpanel">
                <div class="row">
                    <div class="col-md-6">
                        <h4>TestSSL</h4>
                        <div class="input-group mb-3">
                            <input type="text" id="testsslDomain" class="form-control" placeholder="Enter domain">
                            <button class="btn btn-primary" onclick="runTestSSL()">Run TestSSL</button>
                        </div>
                        <div id="testsslResult" class="form-control monospace response-area"></div>
                    </div>
                    <div class="col-md-6">
                        <h4>Wayback Machine</h4>
                        <div class="input-group mb-3">
                            <input type="text" id="waybackUrl" class="form-control" placeholder="Enter URL">
                            <button class="btn btn-primary" onclick="searchWayback()">Search</button>
                        </div>
                        <div id="waybackResult" class="form-control monospace response-area"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script>
        // Enable/disable proxy address input based on checkbox
        document.getElementById('useProxy').addEventListener('change', function() {
            document.getElementById('proxyAddress').disabled = !this.checked;
        });

        // Enable/disable secret key input based on checkbox
        document.getElementById('useSecret').addEventListener('change', function() {
            document.getElementById('secretEntry').disabled = !this.checked;
        });

        // Auto-detect JWTs in request text
        document.getElementById('requestText').addEventListener('input', function() {
            const requestText = this.value;
            if (!requestText.trim()) {
                document.getElementById('jwtText').textContent = 'No JWT tokens found in request';
                return;
            }
            
            fetch('/find_jwt', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    request_text: requestText
                })
            })
            .then(response => response.json())
            .then(data => {
                if (data.tokens && data.tokens.length > 0) {
                    let decodedText = '';
                    data.tokens.forEach((token, index) => {
                        fetch('/decode_jwt', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                            },
                            body: JSON.stringify({
                                token: token
                            })
                        })
                        .then(response => response.json())
                        .then(decodedData => {
                            if (decodedData.decoded) {
                                decodedText += `JWT #${index + 1}:\n${decodedData.decoded}\n\n`;
                                document.getElementById('jwtText').textContent = decodedText;
                            } else {
                                document.getElementById('jwtText').textContent = 'Error decoding JWT';
                            }
                        })
                        .catch(error => {
                            document.getElementById('jwtText').textContent = 'Error decoding JWT';
                        });
                    });
                } else {
                    document.getElementById('jwtText').textContent = 'No JWT tokens found in request';
                }
            })
            .catch(error => {
                document.getElementById('jwtText').textContent = 'Error finding JWT tokens';
            });
        });

        function sendRequest() {
            const requestText = document.getElementById('requestText').value;
            const useProxy = document.getElementById('useProxy').checked;
            const proxyAddress = document.getElementById('proxyAddress').value;
            const verifyCert = document.getElementById('verifyCert').checked;

            fetch('/process_request', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    request_text: requestText,
                    use_proxy: useProxy,
                    proxy_address: proxyAddress,
                    verify_cert: verifyCert
                })
            })
            .then(response => response.json())
            .then(data => {
                if (data.error) {
                    document.getElementById('responseText').textContent = data.error;
                } else {
                    document.getElementById('responseText').textContent = data.response;
                }
            });
        }

        function generateClickjack() {
            const url = document.getElementById('clickjackUrl').value;
            fetch('/generate_clickjack', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    url: url
                })
            })
            .then(response => response.json())
            .then(data => {
                document.getElementById('clickjackResult').textContent = data.html;
            });
        }

        function checkCommonFiles() {
            const requestText = document.getElementById('requestText').value;
            const useProxy = document.getElementById('useProxy').checked;
            const proxyAddress = document.getElementById('proxyAddress').value;
            const verifyCert = document.getElementById('verifyCert').checked;

            const commonFilesResult = document.getElementById('commonFilesResult');
            commonFilesResult.style.display = 'block';
            commonFilesResult.innerHTML = '<div class="text-center"><i class="bi bi-arrow-repeat spin"></i> Checking files...</div>';

            fetch('/check_common_files', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    request_text: requestText,
                    use_proxy: useProxy,
                    proxy_address: proxyAddress,
                    verify_cert: verifyCert
                })
            })
            .then(response => response.json())
            .then(data => {
                if (data.error) {
                    commonFilesResult.innerHTML = `<div class="text-danger">${data.error}</div>`;
                } else {
                    let result = `<div>Total files checked: ${data.total_files_checked}</div>`;
                    result += `<div>Files found: ${data.files_found}</div><br>`;
                    
                    if (data.checked_files && data.checked_files.length > 0) {
                        result += '<div class="mb-3">Checking files:</div>';
                        data.checked_files.forEach(file => {
                            const statusClass = file.success ? 'success' : 'error';
                            const icon = file.success ? 'bi-check-circle-fill' : 'bi-x-circle-fill';
                            result += `<div class="file-status ${statusClass}">`;
                            result += `<i class="bi ${icon}"></i>`;
                            result += `<span>${file.file_path}</span>`;
                            if (!file.success) {
                                result += `<span class="text-muted ms-2">(Status: ${file.status_code || 'Error'})</span>`;
                            }
                            result += '</div>';
                        });
                    }
                    
                    if (data.found_files && data.found_files.length > 0) {
                        result += '<div class="mt-3">Found files:</div>';
                        data.found_files.forEach(file => {
                            result += `<div class="file-status success">`;
                            result += `<i class="bi bi-check-circle-fill"></i>`;
                            result += `<span>${file.file_path}</span>`;
                            result += `<span class="text-muted ms-2">(${file.response_length} bytes)</span>`;
                            result += '</div>';
                        });
                    }
                    
                    commonFilesResult.innerHTML = result;
                }
            });
        }

        function runTestSSL() {
            const domain = document.getElementById('testsslDomain').value;
            fetch('/run_testssl', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    domain: domain
                })
            })
            .then(response => response.json())
            .then(data => {
                if (data.error) {
                    document.getElementById('testsslResult').textContent = data.error;
                } else {
                    document.getElementById('testsslResult').textContent = data.output.join('\n');
                }
            });
        }

        function searchWayback() {
            const url = document.getElementById('waybackUrl').value;
            fetch('/search_wayback', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    url: url
                })
            })
            .then(response => response.json())
            .then(data => {
                if (data.error) {
                    document.getElementById('waybackResult').textContent = data.error;
                } else {
                    let result = `Found ${data.total_results} unique URLs:\n\n`;
                    data.results.forEach(item => {
                        const date = new Date(
                            item.timestamp.substring(0, 4),
                            item.timestamp.substring(4, 6) - 1,
                            item.timestamp.substring(6, 8),
                            item.timestamp.substring(8, 10),
                            item.timestamp.substring(10, 12),
                            item.timestamp.substring(12, 14)
                        );
                        result += `URL: ${item.original}\n`;
                        result += `First Archived: ${date.toLocaleString()}\n`;
                        result += `Status: ${item.statuscode}\n`;
                        result += `Type: ${item.mimetype}\n`;
                        result += `Size: ${(parseInt(item.length) / 1024).toFixed(2)} KB\n`;
                        result += `Archive Link: https://web.archive.org/web/${item.timestamp}/${item.original}\n`;
                        result += "-".repeat(80) + "\n\n";
                    });
                    document.getElementById('waybackResult').textContent = result;
                }
            });
        }

        function runJWTAttacks() {
            // Get the request text from the HTTP Request tab
            const requestText = document.getElementById('requestText').value;
            if (!requestText) {
                alert('No request found. Please enter a request with a JWT token first.');
                return;
            }

            // Get proxy settings
            const useProxy = document.getElementById('useProxy').checked;
            const proxyAddress = document.getElementById('proxyAddress').value;
            const verifyCert = document.getElementById('verifyCert').checked;

            // Find JWT tokens in the request
            fetch('/find_jwt', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    request_text: requestText
                })
            })
            .then(response => response.json())
            .then(data => {
                if (!data.tokens || data.tokens.length === 0) {
                    alert('No JWT token found in request. Please enter a request with a JWT token first.');
                    return;
                }

                // Get the selected attack
                let selectedAttack = null;
                const attackTypes = {
                    'unverifiedSig': 'unverified_sig',
                    'noneSig': 'none_sig',
                    'bruteForce': 'brute_force',
                    'jwkInjection': 'jwk_injection',
                    'kidTraversal': 'kid_traversal',
                    'algorithmConfusion': 'algorithm_confusion'
                };

                for (const [id, attack] of Object.entries(attackTypes)) {
                    if (document.getElementById(id).checked) {
                        selectedAttack = attack;
                        break;
                    }
                }

                if (!selectedAttack) {
                    alert('Please select an attack to run.');
                    return;
                }

                // For brute force attack, show progress in a modal
                if (selectedAttack === 'brute_force') {
                    const modal = document.createElement('div');
                    modal.className = 'modal fade';
                    modal.id = 'bruteForceModal';
                    modal.setAttribute('tabindex', '-1');
                    modal.innerHTML = `
                        <div class="modal-dialog modal-lg">
                            <div class="modal-content">
                                <div class="modal-header">
                                    <h5 class="modal-title">Brute Force Attack Progress</h5>
                                    <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
                                </div>
                                <div class="modal-body">
                                    <div class="progress mb-3">
                                        <div class="progress-bar progress-bar-striped progress-bar-animated" role="progressbar" style="width: 0%"></div>
                                    </div>
                                    <pre id="bruteForceOutput" class="bg-dark text-light p-3" style="max-height: 300px; overflow-y: auto;"></pre>
                                </div>
                            </div>
                        </div>
                    `;
                    document.body.appendChild(modal);
                    const bruteForceModal = new bootstrap.Modal(modal);
                    bruteForceModal.show();

                    // Update output every second
                    const outputInterval = setInterval(() => {
                        fetch(`/jwt_attack/${selectedAttack}`, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                            },
                            body: JSON.stringify({
                                token: data.tokens[0],
                                request_text: requestText,
                                use_proxy: useProxy,
                                proxy_address: proxyAddress,
                                verify_cert: verifyCert
                            })
                        })
                        .then(response => response.json())
                        .then(data => {
                            const output = document.getElementById('bruteForceOutput');
                            if (data.error) {
                                output.textContent = `Error: ${data.error}\nDetails: ${data.details || 'No additional details available'}`;
                                if (data.output && data.output.length > 0) {
                                    output.textContent += '\n\nHashcat Output:\n' + data.output.join('\n');
                                }
                                clearInterval(outputInterval);
                            } else if (data.success) {
                                // Parse the hashcat output to find the JWT:secret line
                                const hashcatOutput = data.output.join('\n');
                                // Look for the line that contains the JWT followed by a colon and the secret
                                const secretMatch = hashcatOutput.match(/^([^:]+):([^\s]+)$/m);
                                if (secretMatch) {
                                    const jwt = secretMatch[1];
                                    const secret = secretMatch[2];
                                    output.textContent = `Success! Found secret: ${secret}\n\nHashcat Output:\n${hashcatOutput}`;
                                } else {
                                    output.textContent = `Success! Found secret: ${data.secret}\n\nHashcat Output:\n${hashcatOutput}`;
                                }
                                clearInterval(outputInterval);
                            } else if (data.output) {
                                output.textContent = data.output.join('\n');
                            }
                        })
                        .catch(error => {
                            const output = document.getElementById('bruteForceOutput');
                            output.textContent = `Error: ${error.message}`;
                            clearInterval(outputInterval);
                        });
                    }, 1000);

                    // Clean up interval when modal is closed
                    modal.addEventListener('hidden.bs.modal', function () {
                        clearInterval(outputInterval);
                    });
                } else {
                    // For other attacks, show alert with results and update the request
                    let message = `${selectedAttack.replace(/_/g, ' ').toUpperCase()}:\n`;
                    if (data.error) {
                        message += `Error: ${data.error}`;
                        alert(message);
                    } else {
                        message += `Success: ${data.success}\n`;
                        if (data.all_results && selectedAttack === 'none_sig') {
                            message += '\nAttempted variations:\n';
                            data.all_results.forEach(result => {
                                message += `\n${result.variation}:\n`;
                                message += `Status Code: ${result.status_code}\n`;
                                message += `Success: ${result.success ? 'Yes' : 'No'}\n`;
                            });
                        }
                        if (data.modified_token) {
                            message += `\nModified Token: ${data.modified_token}\n`;
                            // Update the request with the modified token
                            const newRequestText = requestText.replace(data.tokens[0], data.modified_token);
                            document.getElementById('requestText').value = newRequestText;
                            // Also update the decoded JWT display
                            fetch('/decode_jwt', {
                                method: 'POST',
                                headers: {
                                    'Content-Type': 'application/json',
                                },
                                body: JSON.stringify({
                                    token: data.modified_token
                                })
                            })
                            .then(response => response.json())
                            .then(decodedData => {
                                if (decodedData.decoded) {
                                    document.getElementById('jwtText').textContent = decodedData.decoded;
                                }
                            });
                        }
                        if (data.details) {
                            message += `\nDetails: ${data.details}`;
                        }
                        alert(message);
                    }
                }
            });
        }

        function saveJWT() {
            const decodedText = document.getElementById('jwtText').textContent;
            if (!decodedText || decodedText === 'No JWT tokens found in request') {
                alert('No JWT token found to save.');
                return;
            }

            // Get the current request text
            const requestText = document.getElementById('requestText').value;
            if (!requestText) {
                alert('No request found to update.');
                return;
            }

            // Find the JWT token in the request
            fetch('/find_jwt', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    request_text: requestText
                })
            })
            .then(response => response.json())
            .then(data => {
                if (!data.tokens || data.tokens.length === 0) {
                    alert('No JWT token found in request to replace.');
                    return;
                }

                // Get the original token to replace
                const originalToken = data.tokens[0];
                
                // Edit the JWT using the new endpoint
                fetch('/edit_jwt', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        decoded_text: decodedText,
                        use_secret: document.getElementById('useSecret').checked,
                        secret: document.getElementById('secretEntry').value
                    })
                })
                .then(response => response.json())
                .then(data => {
                    if (data.error) {
                        alert(`Error editing JWT: ${data.error}`);
                        return;
                    }

                    // Replace the original token with the new one in the request
                    const newRequestText = requestText.replace(originalToken, data.encoded_token);
                    document.getElementById('requestText').value = newRequestText;
                    alert('JWT successfully saved and updated in request!');
                });
            });
        }
    </script>
</body>
</html> 